# Как пользовать форматом

Формат в своей основе записывает данные лишь как блоки, и не имеет представления как они будут далее расшифрововаться. Это было сделанно в угоду компактности, и возможности более компактного сжатия при помощи алгоритмов.

По этому вам нужно написать схему которая опишет какие данные находяться внутри обьекта, как их превращать в строку, и как возвращать из формата.

На текущий момент формат в разработке, и находиться в рабочем состоянии, но может быть не ситуативен для некоторых случаев.

## Вложенность и объекты

Самая простая схема выглядит вот так:

```ts
const schema: LWFScheme = {
  // Описываем оглавение которые будет записанно перед блоком данных
  // Т.е. {header}[data]
  // Пускай это будет a
  a: {
    // Ключ объекта который мы будем разбирать в этот блок данных
    key: 'store',
    // Все вложенные данные которые мы можем записать в ряд, не включая обьекты или массивы
    // Здесь должны быть ключи в последовательности, которая будет достаточно эффективна
    // Это конечно не обязательно так заморачиваться, но просто стоит учесть что например ["x", "y"]
    // Не будет эффективно при том что первый x будет часто отсутвовать, ведь оно превратиться в a[,,,10]
    args: ['name', 'owner'],
  },
}

const object = {
  store: {
    name: 'Best Computers!',
    owner: 'Eliot',
  },
}

const result = LWF.stringify(object, schema) // Returns a[Best Computers!,Eliot]
LWF.parse(result, schema) // Will returns object.
```

Теперь мы хотим добавить вложенный обьект, например что продаёт наш магазин

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    // Указываем на оглавление схема которого будет использована для превращения данных внутри
    // обьекта магазина
    includes: ['b'],
  },
  b: {
    key: 'forSale',
    // Указываем что обьект по ключу это массив
    isArray: true,
    args: ['name', 'price'],
  },
}

const object = {
  store: {
    name: 'Best Computers!',
    owner: 'Eliot',
    forSale: [
      {
        name: 'Cool processor',
        price: 'Nice money',
      },
    ],
  },
}

const result = LWF.stringify(object, schema) // Возвращает a[Best Computers!,Eliot]b[Cool processor,Nice money]
LWF.parse(result, schema) // Должен вернуть тот-же обьект что и на входе
```

Для добавления вложенного объекта с ключами, к примеру айди тех самых forSale. Мы сделаем так

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    includes: ['b'],
  },
  b: {
    key: 'forSale',
    // Указываем что обьект по ключу это обьект с вложенными иными поключами
    isKeyedObject: true,
    args: ['name', 'price'],
  },
}

const object = {
  store: {
    name: 'Best Computers!',
    owner: 'Eliot',
    forSale: {
      0: {
        name: 'Cool processor',
        price: 'Nice money',
      },
    },
  },
}

const result = LWF.stringify(object, schema) // Returns a[Best Computers!,Eliot]b[0,Cool processor,Nice money]
LWF.parse(result, schema) // Will returns object.
```

Это и были основые данного формата, и использования его.

## Более сложные схемы

Для указания того как нам работать с корневым элементом нам нужна такая схема

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    // Указываем что эта схема будет работать как корневая, и распространяться на корень всего обьекта
    root: true,
    // Далее мы можем указать всё что нам нужно
    isKeyedObject: true,
    // Или
    isArray: true,
    // И вложенные объекты
    included: [],
  },
}
```

Поскольку формат опускает все пустоты, и не добавляет их в итоговый обьект.
Для указания аргументов которые могут быть пустым, но всегда обязательны мы можем сделать так:

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    root: true,
    // Указываем те обязательные аргументы
    // ["Имя аргумента", "Заменитель если его нету"]
    requiredArgs: [['name', '']],
  },
}
```

Если нам нужно создать обьект но все аргументы записать внутрь вложенного обьекта

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    // Тогда оно запишет не в обьект, а в вложенный обьект с ключом info
    in: 'info',
  },
}
```

На этом пока формат заканчивается, я продолжу разрабатывать его, и совершенствовать

# Основы использования формата

Формат сохраняет данные в виде блоков, не предполагая, каким образом они будут расшифрованы в дальнейшем. Это решение было принято ради компактности и более эффективного сжатия с помощью алгоритмов.

Вам необходимо создать схему, которая будет описывать:
a. Какие данные содержатся внутри объекта.
b. Как эти данные преобразовывать в строку.
c. Как возвращать данные из строкового формата.

На данный момент формат находится в разработке и функционирует, но может быть не универсальным для всех случаев использования.

## Вложенность и объекты

Самая простая схема выглядит вот так:

```ts
const schema: LWFScheme = {
  // Описываем заголовок, который будет записан перед блоком данных
  // Формат: {header}[data]
  // В данном случае заголовок будет "a"
  a: {
    // Ключ объекта, который будет обрабатываться в этом блоке данных
    key: 'store',
    // Все вложенные данные, которые можно записать в одну строку, исключая объекты и массивы
    // Ключи должны быть перечислены в таком порядке, чтобы обеспечить максимальную эффективность
    // Это не строгое требование, но стоит учитывать, что, например, ["x", "y"]
    // будет неэффективно, если первый ключ "x" часто отсутствует, так как это приведет к виду a[,,,10]
    args: ['name', 'owner'],
  },
}

const object = {
  store: {
    name: 'Best Computers!',
    owner: 'Eliot',
  },
}

const result = LWF.stringify(object, schema) // Возвращает a[Best Computers!,Eliot]
LWF.parse(result, schema) // Должен вернуть объект, идентичный входному
```

Теперь добавим вложенный объект, например, чтобы указать, что продает наш магазин:

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    // Указываем заголовок схемы, которая будет использоваться для преобразования данных внутри
    // объекта магазина
    includes: ['b'],
  },
  b: {
    key: 'forSale',
    // Указываем, что объект по этому ключу является массивом
    isArray: true,
    args: ['name', 'price'],
  },
}

const object = {
  store: {
    name: 'Best Computers!',
    owner: 'Eliot',
    forSale: [
      {
        name: 'Cool processor',
        price: 'Nice money',
      },
    ],
  },
}

const result = LWF.stringify(object, schema) // Возвращает a[Best Computers!,Eliot]b[Cool processor,Nice money]
LWF.parse(result, schema) // Должен вернуть объект, идентичный входному
```

Для работы с объектами, ключи которых являются уникальными идентификаторами (например, "forSale"), мы можем указать, что это объект с динамическими ключами. В этом примере мы реализуем это следующим образом:

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    includes: ['b'], // Подключаем схему для вложенного объекта
  },
  b: {
    key: 'forSale',
    // Указываем, что объект по этому ключу является объектом с динамическими ключами
    isKeyedObject: true,
    args: ['name', 'price'],
  },
}

const object = {
  store: {
    name: 'Best Computers!',
    owner: 'Eliot',
    forSale: {
      0: {
        name: 'Cool processor',
        price: 'Nice money',
      },
    },
  },
}

const result = LWF.stringify(object, schema) // Возвращает a[Best Computers!,Eliot]b[0,Cool processor,Nice money]
LWF.parse(result, schema) // Должен вернуть объект, идентичный входному
```

Это были основные принципы работы с данным форматом и его использования.

## Более сложные схемы

Чтобы указать, как работать с корневым элементом, нам понадобится следующая схема:

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    // Указываем, что эта схема будет корневой и применяться ко всему объекту
    root: true,
    // Далее мы можем указать дополнительные параметры
    isKeyedObject: true,
    // Или
    isArray: true,
    // А также вложенные объекты
    included: [],
  },
}
```

Поскольку формат игнорирует пустые значения и не включает их в итоговый объект, для указания аргументов, которые могут быть пустыми, но всегда обязательны, мы можем сделать следующее:

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    root: true,
    // Указываем обязательные аргументы
    // ["Имя аргумента", "Значение по умолчанию, если аргумент отсутствует"]
    requiredArgs: [['name', '']],
  },
}
```

Если нам нужно создать объект, но все аргументы записать внутрь вложенного объекта:

```ts
const schema: LWFScheme = {
  a: {
    key: 'store',
    args: ['name', 'owner'],
    // В этом случае данные будут записаны не в сам объект, а во вложенный объект с ключом "info"
    in: 'info',
  },
}
```

На этом описание формата пока заканчивается. Я продолжу его разработку и улучшение.

# LWFB Specs

Это бинарный формат предназначенный для передачи данных, и для компактного хранения их.

## Принципы хранения данных

Любые данные, с любым типом записываются подобным путём

```

[ TYPE_BYTE ] [ VALUE ]

For string:

[ TYPE_BYTE ] [ LENGTH_LEB128_INT ] [ VALUE ]

```

Для хранения чисел используется два подхода к записи. LEB128 и IEEE754.

Для реализации signed int используется zigzag запись LEB128.

IEEE754 тоже по возможности используется с Little Endian записью.

### Типы данных

```
0x00 - zigzag LEB128
0x01 - unsigned LEB128
0x02 - float32 IEEE754
0x03 - float64 IEEE754
0x04 - boolean
0x05 - string
0x06 - null
```

Для обозначений пропусков в последовательной записи, используется такие типы данных:

```
0x07 - empty
0x08 - empty with count
```

## Блоки данных

Главные структуры в формате, это блоки данных.

Они представляются вот так:

```

[ INDEX_AT_SCHEMA IN LEB128 ] [ VALUES... ]

```

## Принцип работы

Формат серелизирует Map like обьекты в виде последовательного списка значений, без указаний ключей. Это позволяет ему экономить достаточно много места, что-бы быть компактным.

Для более правильного представляния, вот пример:

```
{ "foo": "bar" }

In lwfb:

[ INDEX ] [ STRING_TYPE ] [ LENGTH ] [ VALUE... ]

Or

0x00 0x05 0x03 0x62 0x61 0x72
```

Но что-бы указать каким значениям присущи ключи, нужна схема.

Массивы записуются по принципу того, что схема будет применина на объекты которые находятся в массиве.

А массив будет преобразованы и записанны как и map, но поскольку мы указали в схеме что это массив, мы сможем понять что следующий блок с таким-же индексом, является следующим элементом массива

```
[ { "foo": "bar" }, { "foo": "bar" } ]

In lwfb:

[ INDEX ] [ IS_MAP ] [ STRING_TYPE ] [ LENGTH ] [ VALUE... ] NEXT ELEMENT

Or

[ 0x00 0x01 0x05 0x03 0x62 0x61 0x72 ] [ 0x00 0x01 0x05 0x03 0x62 0x61 0x72 ]
```

Для записи массивов в которых используются разные элементы, и не только элементы типа Map, будут использовано такое преобразование

```
[ { "foo": "bar" }, 1, { "foo": "bar" } ]

[ 0x00 0x01 0x05 0x03 0x62 0x61 0x72 ] [ 0x00 0x00 0x00 0x01 ] [ 0x00 0x01 0x05 0x03 0x62 0x61 0x72 ]
```

Поскольку формат использует понимание, что вложенные объекты доступны по ключу с названием поля, и поним же ориентируется при работе со схемой. По этому для записи объектов которые похожи на массивы по признаку объектов записанных внутри, но с динамическими ключами, можно использовать параметр в схеме позволяющий это реализовать

Тогда запись будет выглядеть так

```
{
   0: { "foo": "bar" },
   1: { "foo": "bar" },
   2: { "foo": "bar" }
}

[ INDEX ] [ KEY ] [ VALUES... ]
```
